/*
 * $Id: server.c,v 1.1 2005/11/08 21:12:06 mkern Exp $
 *
 * Copyright (C) 2005 Markus Kern <mkern@users.berlios.de>
 * Copyright (C) 2005 Tom Hargreaves <hex@freezone.co.uk>
 *
 * All rights reserved.
 */

#include <signal.h>
#include "as_ares.h"
#include "server.h"

/*****************************************************************************/

/*
 * Loads plain text shares file generated by asfilehasher and uploads files
 * to Ares clients. The shares file is reloaded and all previous shares are
 * removed when the daemon receives the HUP signal.
 */

/*****************************************************************************/

/* SIGHUP handler */
static void sighup_handler (int sig_num);

/* Periodic timer which reloads shares file if SIGHUP happened */
static as_bool sighup_timer_func (void *data);

/* loads shares from file into shares manager */
static as_bool load_shares (char *shares_file);

/*****************************************************************************/

static char *shares_file = NULL;
static as_bool sighup_reload_shares = FALSE; /* set to TRUE by SIGHUP and checked
                                           * by timer in event loop. */

/*****************************************************************************/

int main (int argc, char *argv[])
{
	ASLogger *logger;
	in_port_t listen_port = 0;
	timer_id sighup_timer;
	int max_uploads;
	
	if (argc != 4)
	{
		printf ("Usage: asfileserver <shares file> <listen port> <max uploads>\n");
		printf ("Reads shares file and provides shares to Ares clients on listen port.\n");
		printf ("The shares file is reloaded on HUP.\n");
		exit (1);
	}

	shares_file = argv[1];

	if ((listen_port = atol (argv[2])) == 0)
	{
		printf ("Invalid listen port '%s'\n", argv[2]);
		exit (1);
	}

	if ((max_uploads = atoi (argv[3])) <= 0)
	{
		printf ("Invalid number of max uploads '%s'\n", argv[3]);
		exit (1);
	}

	/* setup logging */
	logger = as_logger_create ();
	as_logger_add_output (logger, "stdout");
	as_logger_add_output (logger, "asfileserver.log");

	AS_DBG ("SERVER: Logging subsystem started");

	/* setup event system */
	as_event_init ();

	/* init lib */
	if (!as_init ())
	{
		printf ("FATAL: as_init () failed\n");
		exit (1);
	}

	if (!as_config_set_int (AS_CONF, AS_UPLOAD_MAX_ACTIVE, max_uploads))
	{
		printf ("FATAL: Failed to set AS_UPLOAD_MAX_ACTIVE to %u\n", max_uploads);
		exit (1);
	}

	/* set listening port */
	if (!as_config_set_int (AS_CONF, AS_LISTEN_PORT, listen_port))
	{
		printf ("FATAL: Failed to set listen port to %u\n", listen_port);
		exit (1);
	}

	/* load shares */
	if (!load_shares (shares_file))
	{
		printf ("FATAL: load_shares () failed\n");
		exit (1);
	}

	/* set handler for SIGHUP which reloads shares file */
    if (signal (SIGHUP, sighup_handler) == SIG_ERR)
		AS_WARN ("SERVER: Couldn't set SIGHUP handler");

	/* add timer which checks for SIGHUP flag */
	if ((sighup_timer = timer_add (5*SECONDS, sighup_timer_func, NULL)) == INVALID_TIMER)
		AS_WARN ("SERVER: Couldn't install SIGHUP timer");

	/* run event loop */
	AS_DBG ("SERVER: Entering event loop");
	as_event_loop ();
	AS_DBG ("SERVER: Left event loop");

	/* remove signal handler and timer */
	timer_remove (sighup_timer);
    signal (SIGHUP, SIG_DFL);

	/* cleanup  lib */
	as_cleanup ();

	/* shutdown */
	as_event_shutdown ();
	as_logger_free (logger);

	return 0;
}

static void sighup_handler (int sig_num)
{
	assert (sig_num == SIGHUP);

    /* Re-set handler for next time. */
    signal (SIGHUP, sighup_handler);

	/* Tell event loop about this signal */
	sighup_reload_shares = TRUE;
}

/* Periodic timer which reloads shares file if SIGHUP happened */
static as_bool sighup_timer_func (void *data)
{
	if (sighup_reload_shares)
	{
		AS_DBG ("SERVER: Timer detected SIGHUP");
		
		if (!load_shares (shares_file))
		{
			AS_ERR_1 ("SERVER: Failed to reload shares file '%s' on SIGHUP",
			          shares_file);
		}
		
		sighup_reload_shares = FALSE;
	}

	return TRUE; /* trigger us again */
}

/*****************************************************************************/

/* loads shares from file into shares manager */
static as_bool load_shares (char *file)
{
	FILE *fp;
	char buf[1024*16];
	int nfiles;

	/* load shares */
	if (!(fp = fopen (file, "r")))
	{
		AS_ERR_1 ("SERVER: Failed to open shares file '%s'\n", file);
		return FALSE;
	}

	AS_DBG ("SERVER: Removing all shares");
	as_shareman_remove_all (AS->shareman);

	AS_DBG_1 ("SERVER: Reading shares from '%s'.", file);

	nfiles = 0;
	while (fgets (buf, sizeof (buf), fp))
	{
		char hash64[AS_HASH_BASE64_SIZE];
		char path[PATH_MAX];
		size_t size;
		time_t last_modify;
		ASHash *hash;
		ASShare *share;
		ASRealm realm;

		if (strlen (buf) >= sizeof (buf) - 1)
		{
			AS_ERR ("SERVER: Aborting share load. Line too long.");
			break;
		}

		/* <hash> <size> <last_modify> <path> */
		if (sscanf (buf, "%29s %u %lu %[^\r\n]", hash64, &size, &last_modify, path) != 4)
		{
			AS_ERR ("SERVER: sscanf failed for share.");
			continue;
		}

		/* Ares never shares unknown files. */
		if ((realm = as_meta_realm_from_filename (path)) == REALM_UNKNOWN)
		{
			AS_WARN_1 ("SERVER: Not sharing '%s' because its realm is unknown.", path);
			continue;
		}

		if (!(hash = as_hash_decode (hash64)))
		{
			AS_ERR ("SERVER: Failed to create hash for share.");
			continue;
		}

		if (!(share = as_share_create (path, hash, NULL, size, realm)))
		{
			AS_ERR ("SERVER: Failed to create share object.");
			as_hash_free (hash);
			continue;
		}

		if (!as_shareman_add (AS->shareman, share))
		{
			AS_ERR_1 ("SERVER: Failed to add share '%s' to share manager. Duplicate hash?", path);
			as_share_free (share);
			continue;
		}

		nfiles++;
	}

	fclose (fp);
	AS_DBG_1 ("SERVER: Loaded %d shares.", nfiles);	

	return TRUE;
}

/*****************************************************************************/
